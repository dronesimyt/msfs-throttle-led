<head>
  <meta charset="utf-8" />
  <title>MSFS Throttle LED</title>
</head>

<body style="margin: 0; padding: 0; overflow: hidden">
  <canvas id="c"></canvas>
</body>

<script>
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  // Values coming from Python
  let thr = 0; // 0..100
  let barColor = [255, 0, 0]; // C1
  let bgColor = [0, 0, 60]; // C2

  // NEW: light states from Python
  let strobeOn = false; // STR=0|1
  let beaconOn = false; // BCN=0|1

  // Flash pattern sync
  let seqStartMs = 0;
  let lastActive = false;

  // ---- DESIGN TWEAKS (keep your look) ----
  const PULSE_BG = true;
  const DRAW_THREE_BARS = true;

  const BAR_X = 0.0;
  const BAR_W = 1.0;
  const BAR_H = 0.07;
  const GAP = 0.02;
  const START_Y = 0.55;

  // NEW: top-right square
  const LIGHT_BOX_SIZE = 0.11; // fraction of screen height
  const LIGHT_BOX_MARGIN = 0.02; // fraction of screen height

  function clamp255(n) {
    n = Number(n);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(255, n | 0));
  }

  function handleEvent(evStr) {
    let s = String(evStr ?? "");

    try {
      s = decodeURIComponent(s);
    } catch (e) {}

    // THR=<float>
    let m = s.match(/THR=(\d+(\.\d+)?)/);
    if (m) {
      const v = parseFloat(m[1]);
      if (!Number.isNaN(v)) thr = Math.max(0, Math.min(100, v));
      return;
    }

    // STR=0|1
    m = s.match(/STR\s*=\s*([01])/);
    if (m) {
      strobeOn = m[1] === "1";
      return;
    }

    // BCN=0|1
    m = s.match(/BCN\s*=\s*([01])/);
    if (m) {
      beaconOn = m[1] === "1";
      return;
    }

    // C1/C2=R,G,B
    m = s.match(/C([12])\s*=\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
    if (m) {
      const rgb = [
        clamp255(parseInt(m[2], 10)),
        clamp255(parseInt(m[3], 10)),
        clamp255(parseInt(m[4], 10)),
      ];
      if (m[1] === "1") barColor = rgb;
      else bgColor = rgb;
    }
  }

  // SignalRGB callback
  function onCanvasApiEvent(apiEvent) {
    try {
      if (apiEvent && typeof apiEvent === "object") {
        handleEvent(apiEvent.event);
      } else {
        handleEvent(apiEvent);
      }
    } catch (e) {
      // stay silent in production
    }
  }
  window.onCanvasApiEvent = onCanvasApiEvent;

  function drawBackground(W, H) {
    let [r, g, b] = bgColor;

    if (PULSE_BG) {
      const t = Date.now() / 1000;
      // gentle pulse (keeps your current vibe)
      const mul = 0.88 + 0.12 * (0.5 + 0.5 * Math.sin(t * 1.5));
      r = Math.round(r * mul);
      g = Math.round(g * mul);
      b = Math.round(b * mul);
    }

    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, 0, W, H);
  }

  function drawBar(W, H, nx, ny, nw, nh, frac) {
    const x = Math.round(nx * W);
    const y = Math.round(ny * H);
    const w = Math.max(1, Math.round(nw * W));
    const h = Math.max(1, Math.round(nh * H));

    const fillW = Math.round(w * frac);
    ctx.fillStyle = `rgb(${barColor[0]},${barColor[1]},${barColor[2]})`;
    ctx.fillRect(x, y, fillW, h);

    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.strokeRect(x, y, w, h);
  }

  // NEW: two white flashes, one red flash, synced start
  function drawLightBox(W, H) {
    const active = strobeOn || beaconOn;

    if (active && !lastActive) {
      // lights just turned on -> reset sequence so it always starts white-white-red
      seqStartMs = Date.now();
    }
    lastActive = active;

    // --- ALWAYS draw the box (even when inactive) ---
    const size = Math.round(LIGHT_BOX_SIZE * H);
    const m = Math.round(LIGHT_BOX_MARGIN * H);
    const x = W - m - size;
    const y = m;

    // frame
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.strokeRect(x, y, size, size);

    // black background inside
    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(x + 1, y + 1, size - 2, size - 2);

    if (!active) return;

    // pattern steps (ms)
    // If both: white, off, white, off, red, off
    // If only strobe: white, off, white, off(long)
    // If only beacon: red, off(long)
    let steps;

    if (strobeOn && beaconOn) {
      steps = [
        { on: true, color: [255, 255, 255], dur: 100 }, // white flash 1
        { on: false, dur: 150 }, // gap
        { on: true, color: [255, 255, 255], dur: 100 }, // white flash 2
        { on: false, dur: 450 }, // gap
        { on: true, color: [255, 0, 0], dur: 150 }, // red beacon flash
        { on: false, dur: 300 }, // gap to complete 1s
      ];
    } else if (strobeOn) {
      steps = [
        { on: true, color: [255, 255, 255], dur: 100 },
        { on: false, dur: 150 },
        { on: true, color: [255, 255, 255], dur: 100 },
        { on: false, dur: 650 }, // completes 1s
      ];
    } else {
      steps = [
        { on: true, color: [255, 0, 0], dur: 120 },
        { on: false, dur: 880 },
      ];
    }

    let total = 0;
    for (const s of steps) total += s.dur;

    const t = (Date.now() - (seqStartMs || Date.now())) % total;

    let acc = 0;
    let state = steps[steps.length - 1];
    for (const s of steps) {
      acc += s.dur;
      if (t < acc) {
        state = s;
        break;
      }
    }

    if (!state.on) return;

    const col = state.color;
    ctx.fillStyle = `rgb(${col[0]},${col[1]},${col[2]})`;
    ctx.fillRect(x + 1, y + 1, size - 2, size - 2);
  }

  function loop() {
    const W = Math.max(1, typeof screenWidth === "number" ? screenWidth : 320);
    const H = Math.max(1, typeof screenHeight === "number" ? screenHeight : 200);
    c.width = W;
    c.height = H;

    drawBackground(W, H);

    const frac = Math.max(0, Math.min(1, thr / 100));

    if (DRAW_THREE_BARS) {
      drawBar(W, H, BAR_X, START_Y + 0 * (BAR_H + GAP), BAR_W, BAR_H, frac);
      drawBar(W, H, BAR_X, START_Y + 1 * (BAR_H + GAP), BAR_W, BAR_H, frac);
      drawBar(W, H, BAR_X, START_Y + 2 * (BAR_H + GAP), BAR_W, BAR_H, frac);
    } else {
      drawBar(W, H, 0.0, 0.62, 1.0, 0.25, frac);
    }

    // NEW: strobe/beacon indicator
    drawLightBox(W, H);

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
